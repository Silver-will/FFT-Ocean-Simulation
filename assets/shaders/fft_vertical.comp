#version 460

#define PI 3.14159265358979323846
layout (local_size_x = 256) in;
layout(set = 0, binding = 0,rg32f) readonly uniform image2D input_tex;
layout(set = 0, binding = 1,rg32f) writeonly uniform image2D output_tex;

layout( push_constant ) uniform constants
{
	uint resolution;
	uint ocean_size;
	vec2 wind;
	float delta_time;
	float choppiness;
	uint total_count;
	uint subseq_count;
} PushConstants;


vec2 MultiplyComplex(vec2 a, vec2 b)
{
	return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
}

vec4 ButterflyOperation(vec2 a, vec2 b, vec2 twiddle)
{
	vec2 twiddle_b = MultiplyComplex(twiddle, b);
	vec4 result = vec4(a + twiddle_b, a - twiddle_b);
	return result;
}

void main()
{
	ivec2 pixel_coord = ivec2(gl_WorkGroupID.x, gl_LocalInvocationID.x);

	int thread_count = int(PushConstants.total_count * 0.5f);
	int thread_idx = pixel_coord.y;

	int in_idx = thread_idx & (int(PushConstants.subseq_count) - 1);		
	int out_idx = ((thread_idx - in_idx) << 1) + in_idx;

	float angle = -PI * (float(in_idx) / float(PushConstants.subseq_count));
	vec2 twiddle = vec2(cos(angle), sin(angle));

	vec4 a = imageLoad(input_tex, ivec2(pixel_coord.x, pixel_coord.y));
	vec4 b = imageLoad(input_tex, ivec2(pixel_coord.x, pixel_coord.y + thread_count));

	// Transforming two complex sequences independently and simultaneously

	vec4 result0 = ButterflyOperation(a.xy, b.xy, twiddle);
	vec4 result1 = ButterflyOperation(a.zw, b.zw, twiddle);

	imageStore(output_tex, ivec2(pixel_coord.x, out_idx), vec4(result0.xy, result1.xy));
	imageStore(output_tex, ivec2(pixel_coord.x, out_idx + PushConstants.subseq_count), vec4(result0.zw, result1.zw));
}