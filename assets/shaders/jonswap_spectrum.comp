#version 460
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1)in;
layout(set = 0, binding = 0,rg32f) uniform image2D inital_spectrum;
layout(set = 0, binding = 1,rgba32f)uniform image2D wave_texture;
layout(set = 0, binding = 2,rg32f) readonly uniform image2D gaussian_noise;

const float LowCutoff = 0;
const float HighCutoff = 9999;

layout( push_constant ) uniform constants
{
	int resolution;
	int ocean_size;
	vec2 wind; //x-speed y-angle
	float delta_time;
	float choppiness;
	int total_count;
	int subseq_count;
    float fetch;
    float swell;
    float depth;
    int stage;
    int ping_pong;
} PushConstants;

const float PI = 3.14159265359;
const float g = 9.81;
const float KM = 370.0;
const float CM = 0.23;


float DispersionPeak()
{
    float wind_speed = PushConstants.wind.x;
    return 22 * pow(g * g / (wind_speed * PushConstants.fetch), 0.33);
}

float WaveDispersion(float kLength)
{
    return sqrt(g * kLength);
}

float DispersionDerivative(float kLength)
{
    return g / (2 * sqrt(g * kLength));
}

float fmod(float a, float b)
{
    return a - b * floor(a / b);
}

float GammaApprox(float x)
{
    float firstPart = sqrt(2 * PI / x) * pow(x / exp(1), x);
    float secondPart = 1 + 1 / (12 * x) + 1 / (288 * x * x) - 139 / (51840 * x * x * x) - 571 / (2488320 * x * x * x * x);
    return firstPart * secondPart;
}

float NormalizationFactor(float s)
{
    float firstPart = pow(2, 2*s - 1) / PI;
    float secondPart = pow(GammaApprox(s+1), 2) / GammaApprox(2*s + 1);
    return firstPart * secondPart;
}

float WaveAngle(vec2 k)
{
    
    const float windAngle = PushConstants.wind.y / 180 * PI;
    float angle = atan(k.y, k.x) - windAngle;

    // Normalize the angle to the range [-PI, PI]
    angle = fmod(angle + PI, 2 * PI);
    if (angle < 0)
        angle += 2 * PI;
    return angle - PI;
}

float TMACorrection(float dispersion)
{
    float omegaH = dispersion * sqrt(PushConstants.depth / g);

    if(omegaH <= 1)
        return 0.5 * omegaH * omegaH;
    if(omegaH < 2)
        return 1 - 0.5 * (2 - omegaH) * (2 - omegaH);
    
    return 1; 
}

float JONSWAP(float dispersion)
{
    float wind_speed = PushConstants.wind.x;
    float alpha = 0.076 * pow(wind_speed * wind_speed / (PushConstants.fetch * g), 0.22);
    float omega_p = DispersionPeak();
    float sigma = dispersion <= omega_p ? 0.07 : 0.09;
    float r = exp(-(dispersion - omega_p) * (dispersion - omega_p) / (2 * sigma * sigma * omega_p * omega_p));
    
    float firstPart = alpha * g * g / (dispersion * dispersion * dispersion * dispersion * dispersion);
    float secondPart = exp(-1.25 * pow(omega_p / dispersion, 4));
    float thirdPart = pow(3.3, r);

    return TMACorrection(dispersion) * firstPart * secondPart * thirdPart;
}

float BaseSpread(float dispersion, float angle)
{
    float omega_p = DispersionPeak();
    float omegaOverOmegaPeek = dispersion / omega_p;
    float beta;

    if(omegaOverOmegaPeek < 0.95)
    {
        beta = 2.61 * pow(omegaOverOmegaPeek, 1.3);
    }
    else if(0.95 <= omegaOverOmegaPeek && omegaOverOmegaPeek <= 1.6)
    {
        beta = 2.28 * pow(omegaOverOmegaPeek, -1.3);
    }
    else
    {
        float epsilon = -0.4 + 0.8393 * exp(-0.567 * log(omegaOverOmegaPeek * omegaOverOmegaPeek));
        beta = pow(10, epsilon);
    }
    
    float sech = 1 / cosh(beta * angle);
    
    float firstPart = beta / (2 * tanh(beta * PI));
    float secondPart = sech * sech;

    return firstPart * secondPart;
}

float SwellDirection(float dispertion, float angle)
{
    float s = 16 * tanh(DispersionPeak() / dispertion) * PushConstants.swell * PushConstants.swell;
    return NormalizationFactor(s) * pow(abs(cos(angle/2)), 2 * s);
}

float DirectionalSpread(float dispersion, float angle)
{
    float base = BaseSpread(dispersion, angle);
    float sweel = SwellDirection(dispersion, angle);
    return base * sweel;
}

float IntegratedDirectionalSpread(float dispersion)
{
    float step = 0.01;
    float sum = 0;
    for(float angle = -PI; angle < PI; angle += step)
    {
        sum += DirectionalSpread(dispersion, angle) * step;
    }

    return 1/sum;
}

float FinalDirectionalSpread(float dispersion, float angle)
{
    float integration = IntegratedDirectionalSpread(dispersion);
    float base = BaseSpread(dispersion, angle);
    float swell = SwellDirection(dispersion, angle);
    return integration * base * swell;
}

float Spectrum(float kLength, float dispersion, float angle)
{
    return JONSWAP(dispersion) * FinalDirectionalSpread(dispersion, angle) * DispersionDerivative(kLength) / kLength;
}

vec2 FourierWaveAmplitude(vec2 pos, vec2 k, float dispersion, float angle)
{
    float deltaK = 2 * PI / PushConstants.resolution;
    float kLength = length(k);
    vec2 rand = imageLoad(gaussian_noise, ivec2(pos)).rg;

    return rand * sqrt(2 * Spectrum(kLength, dispersion, angle) * deltaK * deltaK);
}

vec2 WaveVector(vec2 pos)
{
    float n = PushConstants.resolution * 0.5f;
    float k_x = 2 * PI * (pos.x - n) / float(PushConstants.resolution);
    float k_z = 2 * PI * (pos.y - n) / float(PushConstants.resolution);
    vec2 k = vec2(k_x, k_z);

    if (length(k) == 0)
    {
        k.x = 0.0001;
        k.y = 0.0001;
    }
    
    return k;
}

void main()
{
	ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(inital_spectrum);

	if(pixel_coord.x < size.x && pixel_coord.y < size.y)
    {
    vec2 k = WaveVector(pixel_coord);
    float kLength = length(k);
    float dispersion = WaveDispersion(kLength);
    float angle = WaveAngle(k);
    
     vec2 rand = imageLoad(gaussian_noise, pixel_coord).rg;
    if(kLength > LowCutoff && kLength < HighCutoff)
    {
        vec2 h_0 = FourierWaveAmplitude(pixel_coord, k, dispersion, angle);
        imageStore(inital_spectrum, pixel_coord, vec4(h_0.x, h_0.y, 0.f, 0.f));
        imageStore(wave_texture, pixel_coord, vec4(k.x, k.y, dispersion, 1));
    }
    else
    {
        imageStore(inital_spectrum, pixel_coord, vec4(0.f, 0.f,0.f, 0.f));
        imageStore(wave_texture, pixel_coord, vec4(k.x, k.y, 1, 1));
    }
    }
}